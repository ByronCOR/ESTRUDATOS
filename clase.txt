nonoSEMANA 1
esquema intencion
relación, tabla, clase de entidades
estas relaciones están formadas por conjunto de propiedades también llamada atributos columnas, campos (orden no importa)
en el modelo relacional sele puede llamar tuplas filas, registros entidades
clave primaria ,PK, clave principal se asegura que cada fila es unica(solo una y pueden ser simple o compuesta) NO PUEDESER NULO 
clave foránea, FK, foreign key, establece una relación entre la tablas(puede existir muchas en una misma tabla)si puede set nulo o pertener a un padre
el dominio define los valores permitidos para cada atributo(puede  tener restricciones

CREATE TABLE Cliente (
    Id_cliente VARCHAR(11) PRIMARY KEY, 
    Nombre_cliente VARCHAR(50) NOT NULL, 
    Direccion_cliente VARCHAR(50), 
    Telefono_cliente VARCHAR(40)
);

INSERT INTO Cliente (Id_cliente, Nombre_cliente, Direccion_cliente, Telefono_cliente)
VALUES ('001', 'Daniel', 'Calle1', '0997856435'),
('002', 'Maria', 'Calle2', '0991535307'),
('003', 'Fernanda', 'Calle3', '0995684935'),
('004', 'Juan', 'Calle4', '0998143658'),
('005', 'Josselyn', 'Calle5', '0993857496');
SELECT * FROM Cliente;

CREATE TABLE Producto (
Id_producto VARCHAR(11) PRIMARY KEY,
Nombre_producto VARCHAR(50) NOT NULL,
Categoria VARCHAR(50) NOT NULL,
Cantidad_producto INT,
Precio_unidad DECIMAL(10, 2) CHECK (Precio_unidad > 0)
);

INSERT INTO Producto (Id_producto, Nombre_producto, Categoria, Cantidad_producto, Precio_unidad)
VALUES ('584', 'Teléfono Samsung Galaxy','Teléfono', 30, 985),
('685','Computadora Dell Inspiron','Computadora',25,2564),
('357', 'Accesorio Anker Power Bank','Accesorio', 90, 600);

SELECT * FROM Producto;


CREATE TABLE Ventas (
    Id_ventas INT PRIMARY KEY, 
    Id_cliente VARCHAR(11) NOT NULL,
    Nombre VARCHAR(50) NOT NULL, 
    Direccion VARCHAR(50), 
    Telefono VARCHAR(40), 
    Id_producto VARCHAR(20) NOT NULL,
    Fecha DATE, 
    Cantidad INT,
    Precio DECIMAL(10, 2) CHECK (Precio > 0),
    CONSTRAINT FK_clientes FOREIGN KEY (Id_cliente) REFERENCES Cliente (Id_cliente),
    CONSTRAINT FK_producto FOREIGN KEY(Id_producto) REFERENCES Producto (Id_producto)
);

INSERT INTO Ventas (Id_ventas, Id_cliente, Nombre, Direccion, Telefono, Id_producto, Fecha, Cantidad, Precio)
VALUES (1, '001', 'Daniel', 'Calle1', '0997856435', '584', '2024-12-03', 2, 1970),
(2,'002','Maria','Calle2','0991535307','357','2024-03-30',3,1800);

SELECT * FROM Ventas;

SEMANA 2

restricioneslistae email
los dominios son los valores permitidos
esquema  es la (intencion)
el estado the relation es un subconjunto de el plano cartesiano producto de los dominios de los atributos( extension)
las fila no son ordenadas
pero una fila es un conjunto de atributos valores ordenados columna.
valores en la tupla considerados indivisibles.
las constraints o restricciones son los valores permitidos en la base de datos.
claves primarias (no admite nulas y no se repite) hsumarle discriminantes(claves compuestas).
claves foreaneas pueden tener null y valores repetidos.
cual es la cantidad de discriminates es lael numero de atributos que tenga la tabla
cuantos productos se vendi
SELECT OrderDetails.*, Products.ProductName 
FROM OrderDetails LEFT JOIN Products
 ON OrderDetails.ProductID = Products.ProductID
WHERE OrderID=10248;

SELECT OrderDetails.OrderID, COUNT(OrderDetails.ProductId), SUM(Products.Price*OrderDetails.Quantity) AS Subtotal
FROM OrderDetails LEFT JOIN Products ON OrderDetails.ProductID = Products.ProductID,
AND LEFT JOIN Customers ON
GROUP BY OrderDetails.OrderID;

SELECT OrderDetails.OrderID, COUNT(OrderDetails.ProductId), SUM(Products.Price*OrderDetails.Quantity) AS Subtotal
FROM OrderDetails LEFT JOIN Products 
	ON OrderDetails.ProductID = Products.ProductID
GROUP BY OrderDetails.OrderID;

SELECT COUNT(*) AS "Cantidad de productos",
  MIN(Price) AS "Precio Minimo",
    MAX(Price) AS "Precio Maximo",
      AVG(Price) AS "Precio Promedio"
FROM Products
WHERE Products.SupplierID in(1,2,3)
GROUP BY Products.CategoryID;

SELECT Products.CategoryID,
  COUNT(*) AS "Cantidad de productos",
  MIN(Price) AS "Precio Minimo",
  MAX(Price) AS "Precio Maximo",
  AVG(Price) AS "Precio Promedio"
FROM Products
GROUP BY Products.CategoryID;

SELECT COUNT(Price)
FROM Products;

SELECT MIN(Price)
FROM Products;

SELECT MAX(Price)
FROM Products;

SELECT AVG(Price)
FROM Products;

SELECT *
FROM Products
WHERE  Products.ProductName NOT LIKE 'C%';

SELECT *
FROM Suppliers
WHERE Suppliers.ContactName IS NULL;

SELECT *
FROM Suppliers
WHERE Suppliers.ContactName IS NOT NULL;

TAREA

CREATE TABLE Student(
SNN INT PRIMARY KEY,
Name VARCHAR(50),
Major VARCHAR(100),
Bdate DATE
);
CREATE TABLE Course(
Course_C INT PRIMARY KEY,
Cname VARCHAR(50),
Dept VARCHAR(100)
);
CREATE TABLE Text_C(
Book_ISBN VARCHAR(100) PRIMARY KEY,
Book_Title VARCHAR(100),
Publisher VARCHAR(100),
Author VARCHAR(100)
);
CREATE TABLE Book_Adoption(
Course_C INT,
Quarter_C VARCHAR(50),
Book_ISBN VARCHAR(100),
PRIMARY KEY(Course_C, Quarter_C),
CONSTRAINT FK_Book FOREIGN KEY (Book_ISBN) REFERENCES Text_C(Book_ISBN)
);
CREATE TABLE Enroll(
SNN INT,
Course_C INT,
Quarter_C VARCHAR(50),
Grade CHAR(1),
PRIMARY KEY(SNN, Course_C, Quarter_C),
CONSTRAINT FK_SNN FOREIGN KEY (SNN) REFERENCES Student(SNN),
CONSTRAINT FK_Course FOREIGN KEY (Course_C) REFERENCES Course(Course_C),
CONSTRAINT FK_Quarter FOREIGN KEY (Course_C ,Quarter_C) REFERENCES Book_Adoption(Course_C ,Quarter_C)
);
INSERT INTO Student(SNN, Name, Major, Bdate)
VALUES(101,'Emily','Diseño Gráfico','2000-06-03'),
(102,'Daniel','Medicina','2005-09-15'),
(103,'Fatima','Enfermeria','1999-02-24');

INSERT INTO Course(Course_C, Cname, Dept)
VALUES(201,'Phothoshop','Departamento de Artes y Diseño'),
(202,'Anatomía Humana','Departamento de Medicina '),
(203,'Anatomía Humana','Departamento de Ciencias de la Salud');

INSERT INTO Text_C(Book_ISBN, Book_Title, Publisher, Author)
VALUES('978-3-16-148410-0','Fundamentos de Diseño Gráfico','Editorial Creativa', 'Ana Martínez'),
('978-0-13-419044-0','Introducción a la Medicina','Medicina y Salud', 'Dr. Carlos Ruiz'),
('978-1-59327-889-7','Enfermería: Teoría y Práctica','Salud Global', 'Laura Gómez');

INSERT INTO Book_Adoption(Course_C, Quarter_C, Book_ISBN)
VALUES(201,'2024-2025','978-3-16-148410-0'),
(202,'2024-2025','978-0-13-419044-0'),
(203,'2024-2025','978-1-59327-889-7');

INSERT INTO Enroll(SNN, Course_C, Quarter_C, Grade)
VALUES(101, 201,'2024-2025','A'),
(102, 202,'2024-2025','B'),
(103, 203,'2024-2025','C');



SEMANA 3
SELECT *
FROM Order o INNER JOIN Customers c
o.CustomerID + c.CustomerID;

SELECT o.*, c.CustomerNmae, c.Counrr . c.CITY,c.Adress
FROM Order o INNER JOIN Customers c
o.CustomerID + c.CustomerID;

SELECT p.*, s.SupplierName, s.ContactName, s.Phone
FROM Products p INNER JOIN Suppliers s 
     ON p.SupplierID=s.SupplierID;

SELECT p.*, s.SupplierName, s.ContactName, s.Phone,c.CategoryName
FROM ((Products p 
   INNER JOIN Suppliers s ON p.SupplierID=s.SupplierID)
   INNER JOIN Categories c ON p.CategoryID=c.CategoryID)
ORDER By c.CategoryName, p.ProductName;

SELECT *
FROM Customers c LEFT JOIN Orders o
ON c.CustomerID = o.CustomerID;

SELECT *
FROM Customers c LEFT JOIN Orders o
ON c.CustomerID = o.CustomerID
ORDER BY o.OrderID;

ELECT e.*, o.OrderID
FROM Employees e LEFT JOIN Orders o
ON e.EmployeeID = o.EmployeeID
ORDER BY o.OrderID;

SELECT DISTINCT e.EmployeeID, e.LastName, e.FirstName, o.OrderID  
FROM Employees e RIGHT JOIN Orders o
ON e.EmployeeID = o.EmployeeID
ORDER BY e.LastName,e.FirstName;

SELECT DISTINCT e.EmployeeID, e.LastName, e.FirstName, o.OrderID  
FROM Employees e LEFT JOIN Orders o ON e.EmployeeID = o.EmployeeID
ORDER BY e.LastName,e.FirstName
UNION
SELECT DISTINCT e.EmployeeID, e.LastName, e.FirstName, o.OrderID  
FROM Employees e RIGHT JOIN Orders o ON e.EmployeeID = o.EmployeeID
ORDER BY e.LastName,e.FirstName;
CUAL ES EL PRODUCTO QUE COMPRO UN PRODUCTO CON EL PRECIO MAS ALTO
SELECT c.*
FROM Customers c
WHERE CustomersID NOT IN (SELECT DISTINCT

SELECT * 
FROM Products p
WHERE Price = (SELECT MAX(Price)FROM Products);

cual es laorden de la orden que vendio la mayorcantidad de productos individuales


SELECT * 
FROM  OrderDetails
WHERE Quantity = (SELECT MAX(	Quantity)FROM OrderDetails);




1.1.3 Consultas sobre una tabla

  a  Todos
SELECT p.nombre AS "Producto", 
	p.precio AS "EUR",
	p.precio/0.95 AS "USD",	
	ROUND(p.precio/0.95, 2) AS "USD redondeado ",
	TRUNCATE(p.precio/0.95, 2) AS "USD truncado ",
	TRUNCATE(p.precio/0.95, 0) AS "USD truncado "	FROM producto p 
ORDER BY 2 ;

Nelson Piedra | @nopiedra  a  Todos 7:57
#Lista el nombre de todos los productos que hay en la tabla producto.
SELECT *
FROM producto ;

#Lista los nombres y los precios de todos los productos de la tabla producto.

SELECT p.nombre, p.precio
FROM producto p 
ORDER BY 2 ;
#ORDER BY p.nombre ;
#Lista todas las columnas de la tabla producto.
DESC producto ;
DESCRIBE producto ;

#Lista el nombre de los productos, el precio en euros y el precio en dólares estadounidenses (USD).

SELECT p.nombre AS "Producto", 
	p.precio AS "EUR",
	p.precio/0.95 AS "USD",	
	ROUND(p.precio/0.95, 2) AS "USD redondeado ",
	TRUNCATE(p.precio/0.95, 2) AS "USD truncado ,2",
	TRUNCATE(p.precio/0.95, 0) AS "USD truncado ,0"	FROM producto p 
ORDER BY 2 

1. Lista el nombre de todos los productos que hay en la tabla producto.

2. Lista los nombres y los precios de todos los productos de la tabla producto.
#Lista el nombre de todos los productos que hay en la tabla producto.
SELECT *
FROM producto ;

#Lista los nombres y los precios de todos los productos de la tabla producto.

SELECT p.nombre, p.precio
FROM producto p 
ORDER BY 2 ;
#ORDER BY p.nombre ;

3.Lista todas las columnas de la tabla producto.

4. Lista el nombre de los productos, el precio en euros y el precio en dólares estadounidenses (USD).

/*5.Lista el nombre de los productos, el precio en euros y el precio en dólares estadounidenses (USD). Utiliza los siguientes alias para las columnas: nombre de producto, euros, dólares.*/

SELECT p.nombre AS "Producto", 
	p.precio AS "euros",
	p.precio/0.95 AS "dólares"
FROM producto p 
ORDER BY 2 ;

/*6 Lista los nombres y los precios de todos los productos de la tabla producto, convirtiendo los nombres a mayúscula.*/

SELECT UPPER(p.nombre) AS "Producto", 
	p.precio AS "euros",
	p.precio/0.95 AS "dólares"
FROM producto p 
ORDER BY 2 ;

7. Lista los nombres y los precios de todos los productos de la tabla producto, convirtiendo los nombres a minúscula.

SELECT LOWER(p.nombre) AS "Producto", 
	p.precio AS "euros",
	p.precio/0.95 AS "dólares"
FROM producto p 
ORDER BY 2 ;

/*8.Lista el nombre de todos los fabricantes en una columna, y en otra columna obtenga en mayúsculas los dos primeros caracteres del nombre del fabricante.*/
SELECT f.nombre, 
UPPER (substring (f.nombre,1,2)) AS "Siglos"
FROM fabricante f
ORDER BY 1;

/*9.Lista los nombres y los precios de todos los productos de la tabla producto, redondeando el valor del precio.*/

SELECT p.nombre AS "Producto", 	
	TRUNCATE(p.precio, 0) AS "Precio"
FROM producto p 
ORDER BY 2 ;


/*10.Lista los nombres y los precios de todos los productos de la tabla producto, truncando el valor del precio para mostrarlo sin ninguna cifra decimal.*/

DESC producto;
SELECT DISTINCT id_fabricante
FROM producto
ORDER BY 1;

/*11.Lista el identificador de los fabricantes que tienen productos en la tabla producto.*/

SELECT DISTINCT id_fabricante
FROM producto
ORDER BY 1;


/*12.Lista el identificador de los fabricantes que tienen productos en la tabla producto, eliminando los identificadores que aparecen repetidos.*/

SELECT nombre
FROM fabricante
ORDER BY noombre DESC;

/*13.Lista los nombres de los fabricantes ordenados de forma ascendente.*/

SELECT nombre, precio
FROM producto
ORDER BY 1,2 ASC;


/*14.Lista los nombres de los fabricantes ordenados de forma descendente.*/


SELECT nombre, precio
FROM producto
ORDER BY 1,2 DESC;

/* 15.Lista los nombres de los productos ordenados en primer lugar por el nombre de forma ascendente y en segundo lugar por el precio de forma descendente.*/

SELECT nombre, precio
FROM producto
ORDER BY 1,2 DESC;

/* 16.Devuelve una lista con las 5 primeras filas de la tabla fabricante.*/

SELECT *
FROM Fabricante
LIMIT 5;

/* 17.Devuelve una lista con 2 filas a partir de la cuarta fila de la tabla fabricante. La cuarta fila también se debe incluir en la respuesta.*/

SELECT * 
FROM fabricante
ORDER BY id
LIMIT 2 OFFSET 3 ;
  a  Todos
#Devuelve una lista con 2 filas a partir de la cuarta fila de la tabla fabricante. La cuarta fila también se debe incluir en la respuesta.
SELECT *
FROM Fabricante 
ORDER BY id 
LIMIT 3, 2 ;
#LIMIT 3, 3;
#Posgres OFFSET 3 LIMIT 2 ;
#Lista el nombre y el precio del producto más barato. (Utilice solamente las cláusulas ORDER BY y LIMIT)

SELECT nombre, precio
FROM producto
ORDER BY 2
LIMIT 1;

SELECT MIN(precio)
FROM producto ;

# SELECT nombre, MIN(precio) FROM producto ;
#Lista el nombre y el precio del producto más caro. (Utilice solamente las cláusulas ORDER BY y LIMIT)
SELECT nombre, precio
FROM producto
ORDER BY 2 DESC
LIMIT 1;

SELECT MAX(precio) FROM producto ;

/* 18.Lista el nombre y el precio del producto más barato. (Utilice solamente las cláusulas ORDER BY y LIMIT)*/

/* 19.Lista el nombre y el precio del producto más caro. (Utilice solamente las cláusulas ORDER BY y LIMIT)*/

/* 20.Lista el nombre de todos los productos del fabricante cuyo identificador de fabricante es igual a 2.*/


/* 21.Lista el nombre de los productos que tienen un precio menor o igual a 120€.*/
SELECT *
FROM producto
WHERE precio <=120

/* 22.Lista el nombre de los productos que tienen un precio mayor o igual a 400€.*/
SELECT *
FROM producto
WHERE precio >=400

/* 23.Lista el nombre de los productos que no tienen un precio mayor o igual a 400€.*/

SELECT *
FROM producto
WHERE precio <400

/* 24.Lista todos los productos que tengan un precio entre 80€ y 300€. Sin utilizar el operador BETWEEN.*/

/* 25.Lista todos los productos que tengan un precio entre 60€ y 200€. Utilizando el operador BETWEEN.*/

/* 26.Lista todos los productos que tengan un precio mayor que 200€ y que el identificador de fabricante sea igual a 6.*/

/* 27.Lista todos los productos donde el identificador de fabricante sea 1, 3 o 5. Sin utilizar el operador IN.*/

/* 28.Lista todos los productos donde el identificador de fabricante sea 1, 3 o 5. Utilizando el operador IN.*/

/* 29.Lista el nombre y el precio de los productos en céntimos (Habrá que multiplicar por 100 el valor del precio). Cree un alias para la columna que contiene el precio que se llame céntimos.*/

/* 30.Lista los nombres de los fabricantes cuyo nombre empiece por la letra S.*/

/* 31.Lista los nombres de los fabricantes cuyo nombre termine por la vocal e.*/

/* 32.Lista los nombres de los fabricantes cuyo nombre contenga el carácter w.*/

/* 33.Lista los nombres de los fabricantes cuyo nombre sea de 4 caracteres.*/

/* 34.Devuelve una lista con el nombre de todos los productos que contienen la cadena Portátil en el nombre.*/

/* 35.Devuelve una lista con el nombre de todos los productos que contienen la cadena Monitor en el nombre y tienen un precio inferior a 215 €.*/

/* 36.Lista el nombre y el precio de todos los productos que tengan un precio mayor o igual a 180€. Ordene el resultado en primer lugar por el precio (en orden descendente) y en segundo lugar por el nombre (en orden ascendente).*/

SELECT o.OrderID, COUNT (*) AS Productos, SUM(od.Quantity*p.Price) AS subtotal
FROM ((Orders o 
INNER JOIN OrderDetails od ON o.OrderID = od.OrderID)
INNER JOIN Products p ON od.ProductID = p.ProductID)
GROUP BY o.OrderID
ORDER BY 3 DESC
;
SELECT c.CustomerID, c.CustomerName, o.OrderID, SUM(od.Quantity * p.Price) AS Subtotal
FROM ((Orders o 
	INNER JOIN OrderDetails od ON o.OrderId = od.OrderId)
	INNER JOIN Products p ON od.ProductID = p.ProductID)
    INNER JOIN Customers c ON o.CustomerID = c.CustomerID
GROUP BY c.CustomerID, c.CustomerName, o.OrderID
ORDER BY 4 DESC ;

SELECT Year(o.OrderDate), Month(o.orderDate), SUM(od.quantity) AS Subtotal
FROM Orders o INNER JOIN OrderDetails od ON o.OrderID = od.OrderID
GROUP BY Year(o.OrderDate), Month(o.orderDate)
;
Las ventas por meces
Los meses con mayores/menores ventas
Los Meses con Ventas mayores/menores que el promedio
SELECT YEAR(o.OrderDate) AS Año, 
       MONTH(o.OrderDate) AS Mes, 
       MAX(od.Quantity) AS Subtotal
FROM Orders o
INNER JOIN OrderDetails od ON o.OrderID = od.OrderID
GROUP BY Year(o.OrderDate), Month(o.OrderDate);

in general , the select operation is donoted by the 
sigma  <selection condition> (R)wherein general , the select operation is donoted by the 
sigma  <selection condition> (R)where
select  sigma is commutative el orden de los factores no altera el producto
puedo anidar varias seleciones 

PROJECT KEEPS CERTAIN COLUMS (ATRIBUTES)FRom a relation and discardas the orher columns pi dno () pi evita cualquier fila duplicada duplicados la project no es comutativa

pi <atrtibute list>(R)

https://www.w3schools.com/mysql/exercise.asp


•	[1] Realizar una consulta que muestre el nombre de los clientes de Palencia
 π Nombre(σ Ciudad = ”Palencia”(CLIENTES))

•	[2] Indicar el código y descripción de los productos cuyo código coincida con su descripción
PRODUCTO π Cod, Descripción (σ Cod = Descripción ”(EMPLOYEE) )

•	[3] Obtener el nombre de los clientes junto con el identificador de venta y la cantidad vendida, de aquellos productos de los que se vendieron más de 500 unidades
CLIENTES π Nombre(σ Nombre=”  Palencia”(EMPLOYEE))

1. Determinar el nombre y ciudad de residencia de todos los empleados que trabajan en el Banco BANAMEX

π nombre_empleado, ciudad (σ nombre_empresa = 'Banco BANAMEX'(empleado x trabaja) )

2. Determinar el nombre, domicilio y ciudad de residencia de todos los empleados que ganan más de 10.000.

π nombre_empleado, calle ciudad (σ sueldo > 10.000(empleado x trabaja) )

3. Determinar el nombre, domicilio y ciudad de residencia de todos los empleados que trabajan en el Banco BANAMEX y ganan más de 10.000

π nombre_empleado, calle ciudad (σ  nombre_empresa = 'Banco BANAMEX' && sueldo > 10.000 (empleado x trabaja) )

4. Determinar el nombre de los jefes con empleados en la ciudad de Xalapa.

π nombre_jefe (σ  ciudad = 'Xalapa'  (jefe x empleado) )

https://c4model.com/diagrams/container
https://c4model.com


val nume:List[Int]=List(0,1,2,3,4,5,6,7,8,9)

def nomDigito(n:Int):String= {
  if (n == 0) "Cero"
  else if (n == 1) "Uno"
  else  if (n == 2) "Dos"
  else  if (n == 3) "Tres"
  else  if (n == 4) "Cuatro"
  else  if (n == 5) "Cinco"
  else  if (n == 6) "Seis"
  else  if (n == 7) "Siete"
  else  if (n == 8) "Ocho"
  else  if (n == 9) "Nueve"
  else "Error no es un digito"
}

nume.map(nomDigito(_))


case class Estudiante(cedula: String, apellidos: String, nombres: String, edad: Int, peso: Double)
val listaEs = List(Estudiante("1150017950","Ruiz","Martin",20,74.3),
                   Estudiante("1234567890","Garcia","Maria",19,50.0),
                   Estudiante("2343456577","Espina","Roberto",21,80.9),
                   Estudiante("2343556767","Torres","Karen",19,52.4),
                   Estudiante("2334334545","Espinoza","Carlos",20,60.1)
)

listaEs.map(_.edad).sum
listaEs.map(_.peso).sum
listaEs.map(_.edad).sum/listaEs.size
listaEs.map(_.peso).sum/listaEs.size



val promedio: Double = ListE.map(_.edad).sum / ListE.size
val promedioP: Double = ListE.map(_.peso).sum / ListE.size

val mayor: Int = ListE.count(_.edad > promedio)
val menor: Int = ListE.count(_.edad < promedio)
val mayor1: Int = ListE.count(_.peso > promedioP)
val menor1: Int = ListE.count(_.peso < promedioP)

val lista:List[Int]=List(0,1,2,3,4,5,6,7,8,9)
def trasformar(n:Int):String={
  n match{
    case 0=>"Cero"
    case 1=>"Uno"
    case 2=>"Dos"
    case 3=>"Tres"
    case 4=>"Cuatro"
    case 5=>"Cinco"
    case 6=>"Seis"
    case 7=>"Siete"
    case 8=>"Ocho"
    case 9=>"Nueve"
    case _ =>"no es un digito permitido"
  }
}

lista.map(n=>trasformar(n))

case class Estudiante(cedula: String, apellidos: String, nombres: String, edad: Int, peso: Double)
val listaEs = List(Estudiante("1150017950","Ruiz","Martin",20,74.3),
                   Estudiante("1234567890","Garcia","Maria",19,50.0),
                   Estudiante("2343456577","Espina","Roberto",21,80.9),
                   Estudiante("2343556767","Torres","Karen",19,52.4),
                   Estudiante("2334334545","Espinoza","Carlos",20,60.1)
)

listaEs.map(_.edad).sum
listaEs.map(_.peso).sum


val promedio: Double = ListE.map(_.edad).sum / ListE.size
val promedioP: Double = ListE.map(_.peso).sum / ListE.size

val mayor: Int = ListE.count(_.edad > promedio)
val menor: Int = ListE.count(_.edad < promedio)
val mayor1: Int = ListE.count(_.peso > promedioP)
val menor1: Int = ListE.count(_.peso < promedioP)

Ejercicio 3

val palabras:List[String]=List("abeja","pera","uva")
def trasformarNum(p:String):Int={
  p.length
}

palabras.map(p=>trasformarNum(p))


Se pide listar los tipos de entidades
•	Clientes:
•	Artículos:
•	Pedidos:
•	Fábricas:
Por cada tipo de entidad listar los atributos
•	Clientes: Número de Cliente, varias direcciones de envío, Saldo, límite de crédito, descuento


//genere una nueva lista con los nobres de la cancion y artista 
//elementos que nos van ayudarr de forma temproral
val t:Tuple2[Double,Int] = songs
  .map(_.duration)
  .foldLeft((0.0, 0))((acc, currVal) => (acc._1 + currVal, acc._2 + 1))
val avg = t._1 / t._2
val l2: List[Tuple2[String,String]]=songs.filter(_.duration>avg)
  .map(songs=>(songs.name,songs.artistName))
l2.sortBy(_._2).sortBy(_._1)

//tambien es una tuppla pero menos eficioanete
val  tAux:Tuple2[Int, Int]=(songs.map(_.duration).sum,songs.length)

val t3: Tuple3[String, Int, String]=("ecuador",14,"Quito")


//genere una nueva lista con los nobres de la cancion y artista
//elementos que nos van ayudarr de forma temproral
val t:Tuple2[Double,Int] = songs
  .map(_.duration)
  .foldLeft((0.0, 0))((acc, currVal) => (acc._1 + currVal, acc._2 + 1))
val avg = t._1 / t._2
val l2: List[Tuple3[String,String,Double]]=songs.filter(_.duration>avg)
  .map(songs=>(songs.name,songs.artistName,(songs.duration * Math.pow(10,-3))/60))
l2.sortBy(_._2).sortBy(_._1).sortBy(_._3)

//tambien es una tuppla pero menos eficioanete
val  tAux:Tuple2[Int, Int]=(songs.map(_.duration).sum,songs.length)

val t3: Tuple3[String, Int, String]=("ecuador",14,"Quito")
val capitales:Tuple2[(String,String)]=("Ecuador","Quito")
capitales(0)
capitales(1)

val ejemplo:Tuple2[Tuple2[String, String], Int]=(("ecuador","quito"),1668)
case class locura(
tupla:tuple3[douvle, int,string],
name:string)
val locuo = locura((1.0,1,"string"),"milton")
loco.tupla._1


import com.github.tototoshi.csv.*
import java.io.File
implicit object CSVFormatter extends DefaultCSVFormat {
  override val delimiter: Char = ';'
}
val path2Goleadores:String ="C:\\Users\\utpl\\Downloads\\toptengoleadores.csv"
val path2Movies:String="C:\\Users\\utpl\\Desktop\\small_pi_movies.csv"

val reader:CSVReader =
  CSVReader.open(new File(path2Goleadores))

/*
val data: List[List[String]]= reader.all()
//imprimir las filas (Listas)
data.foreach(println)
//imprimir los nombres de los jugadores
data
  .slice(1,data.length)
  .map(row => row(0))
*/

//trabajo con map
val dataMap:List[Map[String,String]]=reader.allWithHeaders()
//imprimir los datos
dataMap.foreach(println)
//imprimir nombres de jugadores
dataMap.foreach(goleador=> println(goleador("Jugador")))
/*analisis exploratorio de datos con estadistica
* que estadisticas se usan
(EDA)
EDA para datos numericos: min, avg,max, stdDev(desviacion estandar), moda, cuartiles
EDA para datos no mumericos: conteo de frecuencias
* */

val listGoles:List[Int]=dataMap
  .map(goleador => goleador("Goles").toInt)
//.map(_.toInt)
val sumCount:Tuple2[Double,Int] = listGoles
  .foldLeft((0.0, 0))((t2, currVal) => (t2._1 + currVal, t2._2 + 1))
println(s"el valor promedio es: ${sumCount._1 / sumCount._2}")
println(s"min.: ${listGoles.min}")
println(s"min.: ${listGoles.max}")
/*
//trabajo con map
val dataMap:List[Map[String,String]]=reader.allWithHeaders()
//imprimir los datos
dataMap.foreach(println)
//imprimir nombres de jugadores
dataMap.foreach(goleador=> println(goleador("Jugador")))
val listPenal:List[Int]=dataMap
  .map(goleador => goleador("Penal").toInt)
//.map(_.toInt)
val sumCount:Tuple2[Double,Int] = listPenal
  .foldLeft((0.0, 0))((t2, currVal) => (t2._1 + currVal, t2._2 + 1))
println(s"el valor promedio es: ${sumCount._1 / sumCount._2}")
println(s"min.: ${listPenal.min}")
println(s"min.: ${listPenal.max}")
val dataMap:List[Map[String,String]]=reader.allWithHeaders()
//imprimir los datos
dataMap.foreach(println)
//imprimir nombres de jugadores
dataMap.foreach(penales=> println(penales("Penal")))
*/
trabajo proyecto analiss exploratorio
realizar una tabla para describir datos  diccionario de datos 
numero de clulmna:enumeracion desde 0 de izquierda aderecha
nombrea: nombre de la colulmna 
tipo de dato: int double string json boolean 
proposito: que informacion esta en la columna?

tratar de leer el archivo completo (aprox.500MB), SI HAY ERROR TRATAR SOLUCIONARLO.
realizar una analisis explorartorio de datos 
numericos max, avg, min, stdDev,mode (una funcion para cada) 
string y boolean: conteo frecuencias(no JSON)

val dataMap:List[Map[String,String]]= 
reader.allWithHeaders()

val budgets:List{Long]=dataMap
.flatMap(row=>
row.get("budget")//List[Option[String]]
.flatMap(bdgt => //List[String]//flat map significa un mapa que destruye una estructura entera el optiones un objeto
scala. util.Try(bdgt.toLong).toOption))//List[Option[Long]]
// voy a incluir o ocuparun try  todo lo que puede causar vuna exception al trabajar con un try el error se convierte en un dato que se encapsula

List(list(1,2),list(3,4),lists(5,6))
flat Map
lists(1,2,3,4,5,6)

un monton de errores porqu si no sqabes qu devolver devuelve null porque no sabe que devolver
Ejemplo

return null:
created method method()
car cadena=methor(_
caena==>null
cadena. toUpperCase()
erro exception java. lang. nullpointerException:cannot invoke"string. to upper case():because"RE

UN MECANISMO PARA EVITAR vALORES DE LOSQUE NO WXISTEN

avg(values:List[Long]):Double=
val sumCount:Tuple2[Double, Int]-values
.filter(_ >0)
.foldLeft((0.0,0))((t2,curVal)=>(t2._1*
sumCount._1/sumCount._2


src main sala new scalqa class/files vamos a darle nombre a ese objeto  objetct



import scala.util.Try
import com.github.tototoshi.csv.*
import java.io.File

object Proyecto {
@main
  def generate():Unit = {
    implicit object CSVFormatter extends DefaultCSVFormat {
      override val delimiter: Char = ';'
  }
    val path2Movies: String = "C:\\Users\\utpl\\Downloads\\pi_movies_complete.csv"

    val reader: CSVReader =
      CSVReader.open(new File(path2Movies))

    val dataMap: List[Map[String, String]] =
      reader.allWithHeaders()

    val budgets: List [Long] = dataMap
    .flatMap (row => row.get ("budget")
    .flatMap (bdgt => Try (bdgt.toLong).toOption))

  def avg(values: List[Long]) : Double =
  val sumCount: Tuple2[Double, Int] = values
    .filter (_ > 0)
    .foldLeft((0.0, 0))((t2, curVal) => (t2._1 + currVal, t2._2 + 1)
      sumCount._1 / sumCount._2

  println(s"avg=${avg(budgets)}")

  val listAdult:List[String]= dataMap
  .flatMap(row => row.get("adult"))

  listAdult
    .distinct
  .foreach(println)

  listAdult
    .groupBy(adlt=>adlt)
    .groupBy(identity)
    .map(entry=>(entry._1,entry._2.length))

[{'cast_id': 12, 'character': 'Tom', 'credit_id': '52fe4217c3a36847f80035fb', 'gender': 2, 'id': 973, 'name': 'Jason Flemyng', 'order': 0, 'profile_path': '/kzzQoiO3bbi2UeDJL9QtBT5jaQn.jpg'}, {'cast_id': 13, 'character': 'Soap', 'credit_id': '52fe4217c3a36847f80035ff', 'gender': 2, 'id': 974, 'name': 'Dexter Fletcher', 'order': 1, 'profile_path': '/did9anJiAFYvTbeQyNZaxts7GaT.jpg'}

El objetivo del dataset es proporcionar una recopilación organizada de información sobre películas y obtener datos de ella  

SELECT id, 
  belongs_to_collection,
	JSON_EXTRACT(REPLACE(belongs_to_collection, "'", "\""), '$.id') AS Id_belongs_to_collection, 
	JSON_EXTRACT(REPLACE(belongs_to_collection, "'", "\""), '$.name') AS name_belongs_to_collection, 
	JSON_EXTRACT(REPLACE(belongs_to_collection, "'", "\""), '$.poster_path') AS poster_path_belongs_to_collection, 
	JSON_EXTRACT(REPLACE(belongs_to_collection, "'", "\""), '$.backdrop_path') AS backdrop_path_belongs_to_collection
FROM Small01 
WHERE LENGTH(belongs_to_collection) > 0

"name": "Crime"}]', '$[*].name') AS name_genres
FROM Small01 ;
 
SELECT id, 
  genres,
  JSON_EXTRACT(REPLACE(genres, "'", '"'), '$[*].id') AS id_genres ,
  JSON_EXTRACT(REPLACE(genres, "'", '"'), '$[*].name') AS name_genres
FROM Small01 ;

SELECT id, 
  genres,
  JSON_EXTRACT(REPLACE(genres, "'", '"'), '$[0].id') AS id_genres ,
  JSON_EXTRACT(REPLACE(genres, "'", '"'), '$[0].name') AS name_genres
FROM Small01 ;

# Invalid JSON text in argument 1 to function json_extract: "Missing a comma or ']' after an array element." at position 164.

SELECT id, 
  	genres,
	REPLACE(genres, "'", '"') genres_replaced,


CREATE TABLE movies(
adult BOOLEAN,
belong_to_collection JSON,
budget INT,
genres JSON,
homepage VARCHAR(100),
id INT,
imdb_id VARCHAR(100),
original_language VARCHAR(100),
original_title VARCHAR(100),
overview VARCHAR(100),
popularity DECIMAL(10, 0),
poster_path VARCHAR(100),
production_companies JSON,
production_countries JSON,
release_date DATE,
revenue DECIMAL(10, 0),
runtime INT,
spoken_languagues JSON,
status VARCHAR(100),
tagline  VARCHAR(100),
title  VARCHAR(100),
video BOOLEAN,
vote_average DECIMAL(10, 0),
vote_count INT,
keywords  VARCHAR(100),
cast JSON,
crew JSON,
ratings JSON
); 


SELECT id,
       JSON_EXTRACT(genres, '$[0].id') AS id_genres,
       JSON_EXTRACT(genres, '$[0].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[0].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[1].id') AS id_genres,
       JSON_EXTRACT(genres, '$[1].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[1].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[2].id') AS id_genres,
       JSON_EXTRACT(genres, '$[2].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[2].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[3].id') AS id_genres,
       JSON_EXTRACT(genres, '$[3].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[3].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[4].id') AS id_genres,
       JSON_EXTRACT(genres, '$[4].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[4].id') IS NOT NULL
   JSON_VALID(genres)  , 
   JSON_VALID(REPLACE(genres, "'", '"') )	
FROM Small01 ;


SELECT s.id AS ID_MOVIE,
       JSON_EXTRACT(s.genres, CONCAT('$[',idx.i,'].id'))
FROM Small01 s          
 JOIN ( SELECT 0 AS i UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 ) idx
ON idx.i < JSON_LENGTH(s.genres);




clase 

  a  Todos
# Borrar si existe tabla
DROP TABLE IF EXISTS Small01 ;
#Crear una réplica de la tabla y preservar la data original  
CREATE TABLE Small01 AS
SELECT * FROM Movies_Small ;
#Consultar los datos extraidos
SELECT * FROM Small01;
#genres <- Arreglo de objetos con el campo id y name
#Ejemplo del campo genres:  [{'id': 35, 'name': 'Comedy'}, {'id': 80, 'name': 'Crime'}]                                                                                                         
SELECT id, 
   genres,
	 REPLACE(genres, "'", '"') genres_replaced,
   JSON_VALID(genres)  , 
   JSON_VALID(REPLACE(genres, "'", '"') )	
FROM Small01 ;
#Error detectado luego de remplazar ' por "
# [{"id": 12, "name": "Adventure"}, {"id": 27, "name": "Horror"}, {"id": 28, "name": "Action"}, {"id": 53, "name": "Thriller"}, {"id": 878, "name": "Science Fiction"}

DAVIDE ALEXANDER MANOTOA  TANDAZO  a  Todos 7:32
UPDATE moviess
SET genres = '[{"id": 53, "name": "Thriller"}, {"id": 878, "name": "Science Fiction"}]'
WHERE genres = '[{"id": 53, "name": "Thriller"}';

LUIS FERNANDO CORDOVA CARRION  a  Todos 7:39
UPDATE pi_movies_small
SET genres = CONCAT(genres, ']')
WHERE genres NOT LIKE '%]' AND id = 100089;

PAULA ALEJANDRA LOPEZ ACARO  a  Todos 7:39
UPDATE pi_movies_small
SET genres = CONCAT(genres, ']')
WHERE id = 100089;

Nelson Piedra | @nopiedra  a  Todos 7:46
UPDATE Small01
SET genres = CONCAT(genres, ']')
WHERE id = 100089;

#Volver a Verificar
SELECT id, 
   genres,
	 REPLACE(genres, "'", '"') genres_replaced,
   JSON_VALID(genres)  , 
   JSON_VALID(REPLACE(genres, "'", '"') )	
FROM Small01 ;

VICENTE ALEXANDER VALDIVIESO JARAMILLO  a  Todos 7:49
SET SQL_SAFE_UPDATES = 0;
UPDATE Small01
SET genres = CONCAT(genres, ']')
WHERE id = 100089;
SET SQL_SAFE_UPDATES = 1;

JUAN SEBASTIAN CUEVA VALDIVIESO  a  Todos 7:55
UPDATE movie_genres
SET genres = CONCAT(genres, ']')
WHERE movie_genres.id = 100089;

DIEGO NICOLAY JIMENEZ CARRION  a  Todos 8:00
UPDATE Small01
SET genres = REPLACE(genres,'\'','"');

JUAN DIEGO GUERRERO CAMARGO  a  Todos 8:00
UPDATE small
SET cast = REPLACE(cast, '\'', '"')
WHERE small.cast LIKE '%\'%';

Nelson Piedra | @nopiedra  a  Todos 8:06
SELECT id, 
  genres,
  JSON_EXTRACT(genres, '$[0].id') AS id_genres ,
  JSON_EXTRACT(genres, '$[0].name') AS name_genres,  
  JSON_EXTRACT(genres, '$[1].id') AS id_genres ,
  JSON_EXTRACT(genres, '$[1].name') AS name_genres,  
  JSON_EXTRACT(genres, '$[2].id') AS id_genres ,
  JSON_EXTRACT(genres, '$[2].name') AS name_genres,  
  JSON_EXTRACT(genres, '$[3].id') AS id_genres ,
  JSON_EXTRACT(genres, '$[3].name') AS name_genres,  
  JSON_EXTRACT(genres, '$[4].id') AS id_genres ,
  JSON_EXTRACT(genres, '$[4].name') AS name_genres  
FROM Small01 ;
SELECT id, 
  genres,
  JSON_EXTRACT(genres, '$[*].id') AS id_genres ,
  JSON_EXTRACT(genres, '$[*].name') AS name_genres  
FROM Small01 ;

JUAN DIEGO GUERRERO CAMARGO  a  Todos 8:17
SELECT id,
       JSON_EXTRACT(genres, '$[0].id') AS id_genres,
       JSON_EXTRACT(genres, '$[0].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[0].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[1].id') AS id_genres,
       JSON_EXTRACT(genres, '$[1].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[1].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[2].id') AS id_genres,
       JSON_EXTRACT(genres, '$[2].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[2].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[3].id') AS id_genres,
       JSON_EXTRACT(genres, '$[3].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[3].id') IS NOT NULL
UNION
SELECT id,
       JSON_EXTRACT(genres, '$[4].id') AS id_genres,
       JSON_EXTRACT(genres, '$[4].name') AS name_genres
FROM small
WHERE JSON_EXTRACT(genres, '$[4].id') IS NOT NULL

Nelson Piedra | @nopiedra  a  Todos 8:25
SELECT id, 
  genres,
  JSON_LENGTH (genres)
FROM Small01 
ORDER BY 3 DESC ;

Nelson Piedra | @nopiedra  a  Todos 8:32
SELECT s.id AS ID_MOVIE,
       JSON_EXTRACT(s.genres, CONCAT('$[',idx.i,'].id'))
FROM Small01 s          
 JOIN ( SELECT 0 AS i UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 ) idx
ON idx.i < JSON_LENGTH(s.genres);
VERSION FINAL de GENRES
SELECT s.id AS ID_MOVIE,
       JSON_EXTRACT(s.genres, CONCAT('$[',idx.i,'].id')) AS id_genre,
       JSON_UNQUOTE(JSON_EXTRACT(s.genres, CONCAT('$[',idx.i,'].name'))) AS name_genre
FROM Small01 s          
 JOIN ( SELECT 0 AS i UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 ) idx
ON idx.i < JSON_LENGTH(s.genres)
ORDER BY 1 ;

USE movies_small;
SELECT JSON_VALID(belongs_to_collection),belongs_to_collection  
FROM Small01;

SELECT s.id AS ID_MOVIES,
       s.belongs_to_collection,
       JSON_VALID(belongs_to_collection) 
FROM Small01 s;


SELECT s.id AS ID_MOVIE, 
	belongs_to_collection,
	JSON_EXTRACT(genres, '$.id') AS id_belongs_to_collection,
	JSON_EXTRACT(genres, '$.name') AS name_belongs_to_collection,
	JSON_EXTRACT(genres, '$.poster_path') AS poster_path_belongs_to_collection,
	JSON_EXTRACT(genres, '$.backdrop_path') AS poster_path_belongs_to_collection		
FROM Small01 s
WHERE JSON_VALID(belongs_to_collection) = 1


USE movies;
CREATE TABLE movies01(
adult VARCHAR(255),
belong_to_collection VARCHAR(255),
budget BIGINT,
genres VARCHAR(255),
homepage VARCHAR(255),
id VARCHAR(255),
imdb_id VARCHAR(255),
original_language VARCHAR(255),
original_title VARCHAR(255),
overview LONGTEXT,
popularity VARCHAR(255),
poster_path VARCHAR(255),
production_companies LONGTEXT,
production_countries VARCHAR(255),
release_date VARCHAR(255),
revenue BIGINT,
runtime INT,
spoken_languagues VARCHAR(255),
status VARCHAR(255),
tagline  VARCHAR(255),
title  VARCHAR(255),
video VARCHAR(255),
vote_average VARCHAR(255),
vote_count INT,
keywords  LONGTEXT,
cast LONGTEXT,
crew LONGTEXT,
ratings LONGTEXT
); 

sbt
no me funciona 
ThisBuild / version := "0.1.0-SNAPSHOT"
ThisBuild / scalaVersion := "3.3.3"

lazy val root = (project in file("."))
  .settings(
    name := "trabajo",
    libraryDependencies ++= Seq(
      "com.github.tototoshi" %% "scala_csv" % "2.0.0",
      "org.tpolecat" %% "doobie-core" % "1.0.0-RC5",
      "org.tpolecat" %% "doobie-hikari" % "1.0.0-RC5",
      "com.mysql" %% "mysql-connector-j" % "9.1.0"
    )
  )


package ec.edu.utpl.computacion.pfr.pi

import doobie._
import doobie.implicits._

import cats._
import cats.effect._
import cats.implicits._

import cats.effect.unsafe.implicits.global

case class Actor(id: Int, name: String, lastname: String)
case class Film(id: Int, title: String, releaseYear: Int, actorList: String)
case class FilmData(id: Int, title: String, releaseYear: Int, actorList: List[Actor], language: String)

object DBDemo {
  @main def demo(): Unit =
    println("Demo")

    val xa = Transactor.fromDriverManager[IO](
      driver = "com.mysql.cj.jdbc.Driver", // JDBC driver
      url = "jdbc:mysql://localhost:3306/sakila", // URL de conexión
      user = "root", // Nombre de la base de datos
      password = "r00t@123", // Password
      logHandler = None // Manejo de la información de Log
    )

    val result:Option[Actor] = find(1)
      .transact(xa)
      .unsafeRunSync()

    println(result.get)

    val actorList: List[Actor] = listAllActors()
      .transact(xa)
      .unsafeRunSync()

    actorList.foreach(println)

    val filmList: List[Film] = listOfFilms()
      .transact(xa)
      .unsafeRunSync()

    filmList.foreach(println)

    println("Movie data")
    val movieData = findFilmDataById(2)
      .transact(xa)
      .unsafeRunSync()

    println(movieData.get)

    val lengthAvg: Double = avgLength()
      .transact(xa)
      .unsafeRunSync()

    println(lengthAvg)

  def find(id: Int): ConnectionIO[Option[Actor]] =
    sql"SELECT a.actor_id, a.first_name, a.last_name FROM actor a where a.actor_id = $id"
      .query[Actor]
      .option

  def listAllActors(): ConnectionIO[List[Actor]] =
    sql"SELECT a.actor_id, a.first_name, a.last_name FROM actor a"
      .query[Actor]
      .to[List]

  def listOfFilms(): ConnectionIO[List[Film]] =
    sql"""
          SELECT f.film_id, f.title, f.release_year, group_concat(CONCAT(a.first_name, ' ', a.last_name)) as actor_list
          FROM film f, film_actor fa, actor a
          WHERE f.film_id = fa.film_id
          AND fa.actor_id = a.actor_id
          GROUP BY  f.film_id, f.title
         """
      .query[Film]
      .to[List]

  def avgLength(): ConnectionIO[Double] =
    sql"""
       |SELECT avg(f.length) as avg_length
       |FROM film f
       |""".stripMargin
      .query[Double]
      .unique

  def findFilmDataById(filmId: Int) =
    def findFilmById(): ConnectionIO[Option[(Int, String, Int, Int)]] =
      sql"""
           |SELECT f.film_id, f.title, f.release_year, f.language_id
           |FROM film f
           |WHERE f.film_id = $filmId
           |""".stripMargin
        .query[(Int, String, Int, Int)]
        .option

    def findLanguageById(languageId: Int): ConnectionIO[String] =
      sql"""
           |SELECT l.name
           |FROM language l
           |WHERE l.language_id = $languageId
           |""".stripMargin
        .query[String]
        .unique

    def findActorsByFilmId(filmId: Int) =
      sql"""
         |SELECT a.actor_id, a.first_name,  a.last_name
         |FROM actor a
         |JOIN film_actor fa on a.actor_id = fa.actor_id
         |WHERE fa.film_id = $filmId
         |""".stripMargin
        .query[Actor]
        .to[List]

    val query = for {
      optFilm <- findFilmById()
      language <- optFilm match {
        case Some(film) => findLanguageById(film._4)
        case None => "".pure[ConnectionIO]
      }
      actors <- optFilm match {
        case Some(film) => findActorsByFilmId(film._1)
        case None => List.empty[Actor].pure[ConnectionIO]
      }
    } yield {
      optFilm.map { film =>
        FilmData(film._1, film._2, film._3, actors, language)
      }
    }
    query
}
import doobie._
import doobie.implicits._
import cats.effect._
import cats.effect.unsafe.implicits.global

case class Actor(id: Int, name: String, lastname: String)
case class Film(id: Int, title: String, releaseYear: Int, actorList: String)
case class FilmData(id: Int, title: String, releaseYear: Int, actorList: List[Actor], language: String)

object DatabaseDemo {
  def main(args: Array[String]): Unit = {

    val xa = Transactor.fromDriverManager[IO](
      driver = "com.mysql.cj.jdbc.Driver",
      url = "jdbc:mysql://localhost:3306/movies",
      user = "root",
      password = "utpl",
      logHandler = None
    )

  CREAR_T().transact(xa).unsafeRunSync()
    INSERTAR_T().transact(xa).unsafeRunSync()

  


  }

  def CREAR_T(): ConnectionIO[Int] =
    sql"""
    CREATE TABLE Usuarios(
    id INT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    edad INT NOT NULL
    );"""
      .update
      .run

    def INSERTAR_T(): ConnectionIO[Int] =
      sql"""
     INSERT INTO Usuarios(id, nombre, edad)
    VALUES(201,'Andrea',15),
    (202,'Fernanda',17),
    (203,'Susana',20);"""
        .update
        .run

    def INSERT_T(): ConnectionIO[Int] =
      sql"""
    INSERT INTO Usuarios(id, nombre, edad)
    VALUES(201,'Andrea',15),
    (202,'Fernanda',17),
    (203,'Susana',20);"""
        .update
        .run




}

ThisBuild / version := "0.1.0-SNAPSHOT"

ThisBuild / scalaVersion := "3.3.4"

lazy val root = (project in file("."))
  .settings(
    name := "untitled3clase",
    libraryDependencies += "com.github.tototoshi" %% "scala-csv" % "2.0.0",
    libraryDependencies += "org.tpolecat" %% "doobie-core" % "1.0.0-RC5",
    libraryDependencies += "org.tpolecat" %% "doobie-hikari" % "1.0.0-RC5",
    libraryDependencies += "com.mysql" % "mysql-connector-j" % "9.1.0",

  )

import doobie._
import doobie.implicits._
import cats.effect._
import cats.effect.unsafe.implicits.global

case class Actor(id: Int, name: String, lastname: String)
case class Film(id: Int, title: String, releaseYear: Int, actorList: String)
case class FilmData(id: Int, title: String, releaseYear: Int, actorList: List[Actor], language: String)

object DatabaseDemo {
  def main(args: Array[String]): Unit = {

    val xa = Transactor.fromDriverManager[IO](
      driver = "com.mysql.cj.jdbc.Driver",
      url = "jdbc:mysql://localhost:3306/movies",
      user = "root",
      password = "utpl",
      logHandler = None
    )



    val edad_Max: Option[Int] = MAX_T.transact(xa).unsafeRunSync()

    print(s"min:  $edad_Max")

    val edad_Min: Option[Int] = MIN_T.transact(xa).unsafeRunSync()

    print(s"max:  $edad_Min")

    val edad_Promedio: Option[Double] = AVG_T.transact(xa).unsafeRunSync()

    print(s"promedio:  $edad_Promedio")

  }



    def INSERTAR_T(id:Int, nombre:String, edad:Int): ConnectionIO[Int] = {
      sql"""
     INSERT INTO Usuarios(id, nombre, edad)VALUES($id,$nombre,$edad)
   """.update
        .run
    }

  def MIN_T: ConnectionIO[Option[Int]] =
    sql"SELECT MIN(edad) FROM usuarios "
      .query[Int]
      .option

  def MAX_T: ConnectionIO[Option[Int]] =
    sql"SELECT MAX(edad) FROM usuarios "
      .query[Int]
      .option


  def AVG_T: ConnectionIO[Option[Double]] =
    sql"SELECT AVG(edad) FROM usuarios "
      .query[Double]
      .option


}

def CREAR_T(): ConnectionIO[Int] ={
  sql"""
  CREATE TABLE Usuarios(
  id INT PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL,
  edad INT NOT NULL
  );"""
    .update
    .run
}
\
SELECT id, CAST, JSON_VALID(Cast),
	REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(Cast, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}'),
	REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(Cast, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}'), '=', '"')
	FROM Movies_Small WHERE id = 100010 ;

CREAR_T().transact(xa).unsafeRunSync()


SELECT id, cast, JSON_VALID(cast) AS is_valid
FROM movies.pi_movies_completetabla
WHERE JSON_VALID(cast) = 0;


UPDATE movies.pi_movies_completetabla
SET cast = REPLACE(
                REPLACE(
                    REPLACE(
                        REPLACE(
                            REPLACE(
                                REPLACE(cast, ', \'', ', "'),
                            '{\'', '{"'),
                        '\': \'', '": "'),
                    '\': ', '": '),
                '\', ', '", '),
            '\'}', '"}')
WHERE JSON_VALID(cast) = 0;

UPDATE movies.pi_movies_completetabla
SET cast =
        REPLACE(cast,': None',': "None"')
WHERE JSON_VALID(cast) = 0;

UPDATE movies.pi_movies_completetabla
SET cast =
        REPLACE(cast,': ""None""',': "None"')
WHERE JSON_VALID(cast) = 0;

USE moviesmall;
DROP TABLE IF EXISTS pi_movies_small_copia;
CREATE TABLE pi_movies_small_copia AS
SELECT * FROM pi_movies_small;

/*BELONGS_TO_COLLECTION*/

SELECT id, belongs_to_collection, JSON_VALID(belongs_to_collection) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(belongs_to_collection) = 0;

SELECT id, belongs_to_collection, JSON_VALID(belongs_to_collection) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(belongs_to_collection) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET belongs_to_collection = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(belongs_to_collection, ', \'', ', "'),
                            '{\'', '{"'),
                        '\': \'', '": "'),
                    '\': ', '": '),
                '\', ', '", '),
            '\'}', '"}')
WHERE JSON_VALID(belongs_to_collection) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET belongs_to_collection = REPLACE(belongs_to_collection, ': None', ': null')
WHERE JSON_VALID(belongs_to_collection) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET belongs_to_collection = '{}'
WHERE JSON_VALID(belongs_to_collection) = 0;

/*KEYWORDS*/

SELECT id, keywords, JSON_VALID(keywords) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(keywords) = 0;

SELECT id, keywords, JSON_VALID(keywords) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(keywords) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET keywords = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(keywords, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(keywords) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET keywords = REPLACE(keywords, '=', '"')
WHERE JSON_VALID(keywords) = 0;

/*CAST*/

SELECT id, cast, JSON_VALID(cast) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(cast) = 0 AND id = 100042;

SELECT id, cast, JSON_VALID(cast) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(cast, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, '=', '"')
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, ': None', ': null')
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(cast, ', "', ', ='), '{"', '{='), '": "', '=: ='), '": ', '=: '), '", ', '=, '), '"}', '=}')
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, '"', '\'')
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, '=', '"')
WHERE JSON_VALID(cast) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, '"name": "Erin Allin O\'Reilly\'', '"name": "Erin Allin O\'Reilly"')
WHERE JSON_VALID(cast) = 0
AND id =100042;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, ', {"cast_id": 76, "character": "Inventor No. 2", "credit_id": "545f72ed0e0a2', ']')
WHERE JSON_VALID(cast) = 0
AND id =100042;

UPDATE moviesmall.pi_movies_small_copia
SET cast = REPLACE(cast, '{"cast_id": 81, "character": "Dancer", "credit_id": "52fe42e5c3a36847f802afe3", "gender": 0, "id": 1172407, "name": "Thea Samuels", "order": 69, "profile_path": null}, {',
                   '{"cast_id": 81, "character": "Dancer", "credit_id": "52fe42e5c3a36847f802afe3", "gender": 0, "id": 1172407, "name": "Thea Samuels", "order": 69, "profile_path": null}]')
WHERE JSON_VALID(cast) = 0
AND id =1018;

/*Para remplazar el valor de la tabla original a la tabla copia por si cometo un error*/
UPDATE moviesmall.pi_movies_small_copia AS copia
JOIN moviesmall.pi_movies_small AS original ON copia.id = original.id
SET copia.cast = original.cast
WHERE JSON_VALID(original.cast) = 0
AND copia.id = 1018;

/*CREW*/
SELECT id, crew, JSON_VALID(crew) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(crew) = 0;

SELECT id, crew, JSON_VALID(crew) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(crew) = 0;
/*97 errores*/
UPDATE moviesmall.pi_movies_small_copia
SET crew = REPLACE(crew, ': None', ': null')
WHERE JSON_VALID(crew) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET crew = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(cast, ', "', ', ='), '{"', '{='), '": "', '=: ='), '": ', '=: '), '", ', '=, '), '"}', '=}')
WHERE JSON_VALID(crew) = 0;
/*91 errores*/

UPDATE moviesmall.pi_movies_small_copia
SET crew = REPLACE(crew, '=', '"')
WHERE JSON_VALID(crew) = 0;

/*0 errores*/

/*GENRES*/
SELECT id, genres, JSON_VALID(genres) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(genres) = 0;

SELECT id, genres, JSON_VALID(genres) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(genres) = 1;

UPDATE moviesmall.pi_movies_small_copia
SET genres = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(genres, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(genres) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET genres = REPLACE(genres, '=', '"')
WHERE JSON_VALID(genres) = 0;
/*0 errores*/

/*PRODUCTION_COMPANIES*/

SELECT id, production_companies, JSON_VALID(production_companies) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(production_companies) = 0;

SELECT id, production_companies, JSON_VALID(production_companies) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(production_companies) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET production_companies = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(production_companies, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(production_companies) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET production_companies = REPLACE(production_companies, '=', '"')
WHERE JSON_VALID(production_companies) = 0;

/*Para remplazar el valor de la tabla original a la tabla copia por si cometo un error*/
UPDATE moviesmall.pi_movies_small_copia AS copia
JOIN moviesmall.pi_movies_small AS original ON copia.id = original.id
SET copia.production_companies = original.production_companies
WHERE JSON_VALID(original.production_companies) = 0
AND copia.id = 101362;

UPDATE moviesmall.pi_movies_small_copia
SET production_companies = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(production_companies, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(production_companies) = 0 AND id = 101362;

UPDATE moviesmall.pi_movies_small_copia
SET production_companies = REPLACE(production_companies, '"', '\'')
WHERE JSON_VALID(production_companies) = 0 AND id = 101362;

/*PRODUCTION_COUNTRIES*/

SELECT id, production_countries, JSON_VALID(production_countries) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(production_countries) = 0;

SELECT id, production_countries, JSON_VALID(production_countries) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(production_countries) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET production_countries = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(production_countries, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(production_countries) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET production_countries = REPLACE(production_countries, '=', '"')
WHERE JSON_VALID(production_countries) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET production_countries = REPLACE(production_countries, '{"iso_3166_1": "NL", "name": "Netherlands"}, {"iso_3166_1": "DE''', '{"iso_3166_1": "NL", "name": "Netherlands"}]')
WHERE JSON_VALID(production_countries) = 0 AND id = 101006;

/*SPOKEN_LANGUAGES*/

SELECT id, spoken_languages, JSON_VALID(spoken_languages) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(spoken_languages) = 0;

SELECT id, spoken_languages, JSON_VALID(spoken_languages) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(spoken_languages) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET spoken_languages = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(spoken_languages, ', \'', ', ='), '{\'', '{='), '\': \'', '=: ='), '\': ', '=: '), '\', ', '=, '), '\'}', '=}')
WHERE JSON_VALID(spoken_languages) = 0;

UPDATE moviesmall.pi_movies_small_copia
SET spoken_languages = REPLACE(spoken_languages, '=', '"')
WHERE JSON_VALID(spoken_languages) = 0;


/*RATINGS este atributo no presento algun error*/

SELECT id, ratings, JSON_VALID(ratings) AS is_valid
FROM moviesmall.pi_movies_small
WHERE JSON_VALID(ratings) = 0;


//capa de presentcion sepuede presentar mensajes ni en la capada logica no hay j optionpane para presentara
SELECT id, ratings, JSON_VALID(ratings) AS is_valid
FROM moviesmall.pi_movies_small_copia
WHERE JSON_VALID(ratings) = 0;

BASE DE DATOS AVANZADA
desde un usuario A a un Usuario b debo darle permisos
1 primero hay que crea un suario usr_consulta
-------------------------------------
DBA
create user_consulta IDENTIFIED by pwdconsulta;

GRANT CONNECT to USR_consulta
GRANT RESOURSE to USR_consulta

alter user hr account unlock;
alter usr hr IDENDETIFied by pwdhr;

GRANT CREATE VIEW TO usr_consulta;


------------------------------------
practicaPErmisos

select*
from hr.copy_emp
where employee_id=999;

UPDATE hr.copy_emp SET first_name ='Ramiro'
WHERE employe_id

DELETE FROM hr.copy_emp
WHEREemployee_id=999;

rollback;

select *
from hr.V_EMP1;
select *
from hr.V_EMP2;
----------------------
hrUser

from user_tables;
GRANT SELECT ON employees TO usr_consulta;
GRANT SELECT, INSERT, UPDATE,DELETE ON copy_emp TO usr_consulta;
REVOKE SELECT, INSERT, UPDATE ON copy_emp TO usr_consulta;

CREATE TABLE copy_emp AS
SELECT*
FROMemployees;
drop table copy_emp;
select* from copy_emp;

CREATE VIEW v_emp1 AS
select last_name, first_name, job_id
from employees
ORDER BY 1;


CREATE VIEW v_emp1 AS
select last_name, first_name, DEPARTMENT_NAME
from employees e, departments d
WHERE e.department_id = d.department_id
ORDER BY 3, 1;

GRANT SELECT ON V_EMP1 TO usr_consulta
GRANT SELECT ON V_EMP2 TO usr_consulta

una vista se lallama tabla virtual es una forma de ocultar mis datos
-----------------
n=2
 n-1 join

INSERT INTO hr.copy_emp
VALUES(999,'William','Gietz','WGIETZ",'515.123.8181',
'07/06/2002','AC_ACCOUNT',*300, null,110);


GRANT SELECT, INSERT, UPDATE ON copy_emp TO usr_consulta;
GRANT SELECT ON employees TO usr_consulta


practicaPErmisos nueva coneccion
alter user hr account unlock
alter user hr indetified by bazinga
SELECT*
FROM HR.COPY_EMP
WHERE EMPLOYEE_ID_999;

UPDATE copy_emp SET first_name_ 'Ramiro'
WHERE employee_id = 999;

